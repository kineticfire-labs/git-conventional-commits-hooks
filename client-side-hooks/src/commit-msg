#!/usr/bin/env bb

(ns commit-msg.main
  (:require [clojure.string    :as str]
            [babashka.cli      :as cli]
            [babashka.process  :refer [shell process exec]]))



;; version updated by CI pipeline
(def ^:const version "latest")

(def ^:const config-file "commit-msg.cfg.json")

(def ^:const shell-color-red "\\e[1m\\e[31m")

(def ^:const shell-color-blue "\\e[34m")

(def ^:const shell-color-white "\\e[0m\\e[1m")

(def ^:const shell-color-reset "\\033[0m\\e[0m")


(defn ^:impure run-shell-command
  "Runs commands in 'lines', as either a string or vector of strings, by using 'shell'."
  [lines]
  (if (= (.getSimpleName (type lines)) "String")
    (run-shell-command [lines])
    (dorun (map shell lines))))


(defn apply-display-with-shell
  "Applies 'echo -e' to each line in 'lines', which supports display to the terminal with color coding, and returns the result.  If argument 'lines' is a string, then returns a string; if 'lines' is a vector of strings, then returns a vector of strings."
  [lines]
  (if (= (.getSimpleName (type lines)) "String")
    (str "echo -e " lines)
    (map #(str "echo -e " %) lines)))


(defn generate-shell-newline-characters
  "Generates newline characters understood by the terminal and returns the string result.  Displays one newline without arguments or int 'num' newlines."
  ([]
  (generate-shell-newline-characters 1))
  ([num]
  (vec (repeat num "\n"))))


(defn generate-commit-msg-offending-line-header
  "Generates a header that indicates an offending line that was in error, if 'line-num' is integer 0 or greater; 'line-num' is indexed starting at 0.  Appends the header line to the vector of strings 'lines' and returns the result or, if no header should be generated, returns 'lines' unchanged."
  [lines line-num]
  (if (< line-num 0)
    lines
    (conj lines (str "\"   (offending line # " (inc line-num) " in red) **************\""))))


(defn generate-commit-msg-offending-line-msg-highlight
  "Adds shell color-code formatting for an offending line identified by integer 'line-num' in the vector of strings 'lines'.  Argument 'line-num' is indexed starting at 0.  If 'line-num' is negative, then 'lines' is returned unchanged."
  [lines line-num]
  (if (< line-num 0)
    lines
    (assoc lines line-num (str shell-color-red (nth lines line-num) shell-color-reset))))


(defn generate-commit-msg
  "Generates a formatted commit message, 'msg', with optional call-out to the offending line if the optional integer 'line-num' is non-negative; 'line-num' is indexed starting at 0.  Returns the result as a vector of strings, formatted for shell output with color-coding."
  ([msg]
   (generate-commit-msg msg -1))
  ([msg line-num]
   (let [start-lines-top
         [(str "\"" shell-color-blue "**********************************************\"")
          "\"BEGIN - COMMIT MESSAGE ***********************\""]
         start-line-end
         (str "\"**********************************************" shell-color-reset"\"")
         end-lines
         [(str "\"" shell-color-blue "**********************************************\"")
          "\"END - COMMIT MESSAGE *************************\""
          (str "\"**********************************************" shell-color-reset "\"")]]
     (apply-display-with-shell 
      (into (into (conj (generate-commit-msg-offending-line-header start-lines-top line-num) start-line-end) (generate-commit-msg-offending-line-msg-highlight msg line-num)) end-lines)))))


(defn generate-commit-warn-msg
  "Generates and returns as a string a warning message including the string 'warn-msg', formatting the string for shell output with color-coding."
  [warn-msg]
  (apply-display-with-shell (str "\"" shell-color-blue "WARNING (local): " warn-msg "  Commit proceeding." shell-color-reset "\"")))


(defn generate-commit-err-msg
  "Generates and returns as a vector of strings an error message including the string 'err-msg', formatting the string for shell output with color-coding."
  [err-msg]
  (apply-display-with-shell
   [(str "\"" shell-color-red "[COMMIT REJECTED local]\"")
    (str "\"" shell-color-white "Commit failed: " err-msg "\"")]))


(defn ^:impure exit
  [value]
  (System/exit value))


(defn ^:impure handle-err-exit
  "Generates and displays to the shell an error message, including the string 'err-msg', using color-coding from the shell.  Optionally accepts vector of strings 'commit-msg' which display the original commit message; and optionally accepts the integer 'line-num', indexed at 0, which displays a message about the offending line and highlights it in the commit message.  Exits with return code 1."
  ([err-msg]
   (run-shell-command (generate-commit-err-msg err-msg))
   (exit 1))
  ([err-msg commit-msg]
   (run-shell-command (generate-commit-err-msg err-msg))
   (run-shell-command (generate-commit-msg commit-msg))
   (exit 1))
  ([err-msg commit-msg line-num]
   (run-shell-command (generate-commit-err-msg err-msg))
   (run-shell-command (generate-commit-msg commit-msg line-num))
   (exit 1)))


(defn ^:impure handle-warn-proceed
  "Generates and displays to the terminal a warning message, including the string 'warn-msg', using color-coding from the shell."
  [warn-msg]
  (run-shell-command (generate-commit-warn-msg warn-msg)))


(defn string-to-vector
  "Converts and returns the string 'lines' to a vector split on newlines.  A wrapper around 'clojure.string/split-lines'."
  [line]
  (str/split-lines line))


(defn is-string-min-char-compliant?
  "Returns 'true' if 'line' has 'min-chars' characters or more and 'false' otherwise."
  [line min-chars]
  (if (>= (count line) min-chars)
    true
    false))


(defn is-string-max-char-compliant?
  "Returns 'true' if string 'line' has 'max-chars' characters or fewer and 'false' otherwise."
  [line max-chars]
  (if (<= (count line) max-chars)
    true
    false))

;; In addition to clojure.core, the following libraries / namespaces are available in babashka.
;; cheshire.core aliased as json: dealing with JSON
(defn get-parse-config-file
  []
  )




(defn dostuff
  [args]
  (println "hi"))



;; start
;;todo
;;
;; - get path of git editmsg from command line arg
;;    - err w/ exit 1 if not 1 arg
;;
;; - parse config file json into a map
;;    - err w/ exit 1 if can't read file
;;    - err w/ exit 1 if can't parse json
;;
;; - if enabled=false, then warning and exit 0
;;
;; - read git editmsg from file and keep as string
;;    - err w/ exit 1 if can't read file
;; - reformat commit message
;; - write commit message
;;
;; - validate commit message
;;    - check if empty, then exit 1
;;    - convert editmsg string to vector of strings split on newline
;;    - group
;;       - check if contains tabs, then get line num and exit 1
;;       - check for (1) one line only or (2) line, newline, rest
;;       - check for min/max chars (first line min/max diff from others)
;;    - subject
;;       - x
;;    - body
;;       - x
;;
;;
;; ...
;; - err w/ exit 1 if can't read/write git editmsg file
;;
(let [args *command-line-args*]
  (if (= (count args) 1)
    (dostuff (first args))
    (handle-err-exit "Exactly one argument required.")))



;; ------------------------------------------------------------------
;; ------------------------------------------------------------------
;; ------------------------------------------------------------------


(defn get-commit-msg
  [filename]
  (slurp filename))


;;(handle-err-exit "A big error occured." ["feat(client): added new feature" "A really big commit message" "would span multiple lines" "much line this one does"] 2)


;;(let [commit-msg-cfg "commit-msg.cfg.json"])
;;(".git/COMMIT_EDITMSG")


