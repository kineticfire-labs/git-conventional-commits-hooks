#!/bin/env bash
# (c) Copyright 2023 KineticFire. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


# KineticFire Labs
#	  Project site:  https://github.com/kineticfire-labs/git-conventional-commits-hooks


##########################################################################
##########################################################################
##########################################################################
# Setup & Usage
# 
# Setup
#    - Add this script to <git repository>/.git/hooks/commit-msg'
#	  - Make this script executable with 'chmod +x <path to script>' 
#    - Set the default editor for git ('vim' in the example below)
#         - git config --global core.editor vim
#
# Usage
#    - This script will be invoked by git during commits.  Run the command 'git commit'.
#
# Limitations
#    - This is a client-side script, which is enforcing the conventions at the client only and not the server.



##########################################################################
##########################################################################
##########################################################################
# Detailed Description
#
# If '.enabled' in the config file is 'false', then this script will exit and return 0 (allowing the commit) without reformatting or validation described below.
#
# This script will exit and return 1 (rejecting the commit) if one of the following are true, else this script will return 0 (accepting the commit):
#  - the configuration file cannot be read
#  - a property of the configuration file cannot be found
#  - the validation of the commit message fails
#
# The commit message reformatting and validation follows the Conventional Commits specification (https://www.conventionalcommits.org/en/v1.0.0/).  A commit message consists of at least one line.  If additional lines are given, then the body is separated from the subject line by exactly one newline. So a commit message may take the following two general forms.  This script requires a 'type' and 'scope'; the '!' is optional.  See the Conventional Commits specification for more detail, and consult your project's specific configuration for valid git commit messages.
#
# (1)
#   --- start ---
#   <type>(<scope>)!: <subject>
#   ---- end ----
#
# (2)
#   --- start ---
#   <type>(<scope>)!: <subject>
#
#   <body>
#   ---- end ----
#
# The commit message is re-formatted prior to validation as follows:
#  - Remove all lines with comments
#  - Replace a line containing only spaces (e.g. 1 or more spaces and newline) with a newline only
#  - Replace two or more empty lines (e.g. newlines that may contain 0 or more spaces) with a single empty line
#  - Remove trailing newlines
#  - For the title line (e.g. the first line):
#    - Remove extra spaces before and after the 'type'
#    - Remove extra spaces before and after the opening and closing parenthesis for the 'scope'
#    - Remove extra spaces before and after the optional exclamation mark following the 'type' and 'scope' and prior to the colon
#    - Remove extra spaces before and after the colon
#  - For the body:
#    - converts the following to 'BREAKING CHANGE: '
#      - 'BREAKING CHANGE', regardless of case
#      - 'BREAKING' if mis-spelled 'BRAKING' or 'BRAEKING'
#      - 'BREAKING' and 'CHANGE' if separated by 0 or more spaces, a dash, or underscore
#      - multiple spaces before or after the colon
#
# The commit message is valid if, after reformatting, the following are all true:
#  - Title line must be a valid subject
#    - At least length.titleLine.min characters (from config file) in length
#    - No more than length.titleLine.max characters (from config file) in length
#    - '<type>(<scope>)!: <subject>' where 'type' and 'scope' are defined in the config file, type and scope are required , and '!' optionally indicates a breaking change.  The subject must begin with a lowercase letter.
#    - Examples with type of 'feat' and scope of 'app': 
#      - Non-breaking change:
#        - feat(app): add this feature
#      - Breaking change:
#        - feat(app)!: add this feature
#  - After the title line:
#    - Option 1: title line only, no body
#      - end of file
#    - Option 2: with body
#      - one newline
#      - body, which can contain text and newlines
#      - optional single 'BREAKING CHANGE: <description>'
#      - end of file
#
# Requirements:
#  - bash
#  - sed
#  - jq
#  - cat
#  - tail
#  - head

######################################################
# Define settings

#todo
# 'version' will be replaced by CI pipeline
#version=@filter-token.client-side-hooks-commit-message.version@

# set configuration file
config=commit-msg.cfg.json





######################################################
# Define globals

commitMsg="$1"



######################################################
# Define functions


# $1 is String error message
function display_error_message {

	local errMsg="$1"

	echo -e "\e[1m\e[31m[COMMIT REJECTED (local)]"
	echo -e "\e[0m\e[1mCommit failed: $errMsg"
}


# $1 is String warning message
function display_warning_proceed {

	local warningMsg="$1"

	echo -e "\e[34mWARNING (local): $warningMsg  Commit proceeding.\033[0m\e[0m"
}


# $1 is String warning message
# $2 is optional integer line number to highlight in red
function display_commit_message {

	local warningMsg="$1"
	local lineNumber="$2"

	echo -e "\e[34m**********************************************"
	echo 'BEGIN - COMMIT MESSAGE ***********************'
	if [[ -n "$lineNumber" ]]; then
		echo "   (offending line # $lineNumber in red) **************"
	fi
	echo -e "**********************************************\033[0m\e[0m"

	local count=0

	while IFS= read -r line
	do
		(( "count++" ))
		if [[ -n "$lineNumber" ]] && [ "$count" -eq "$lineNumber" ]; then
			echo -e "\e[1m\e[31m$line\033[0m\e[0m"
		else
			echo "$line"
		fi
	done < "$warningMsg"

   echo -e "\e[34m**********************************************"
	echo 'END - COMMIT MESSAGE *************************'
   echo -e "**********************************************\033[0m\e[0m"
}


# $1 is String warning message
# $2 is the commit message
# $3 is optional integer line number to highlight in red
function display_error {

	local warningMsg="$1"
	local commitMsg="$2"
	local lineNumber="$3"

	echo -e "\n"
	display_error_message "$warningMsg"
	echo -e "\n"
	display_commit_message "$commitMsg" "$lineNumber"
	echo -e "\n"
}


function display_info {
	echo "Version $version"
}


# $1 is the String to evaluate
# $2 is the int min number of chars
# return: 0 is compliant, 1 is not compliant
function is_string_min_char_compliant {

	local data="$1"
	local minChars="$2"

	local ok=0

	if [ "${#data}" -lt "$minChars" ]; then
		ok=1
	fi

	return $ok
}


# $1 is the String to evaluate
# $2 is the int max number of chars
# return: 0 is compliant, 1 is not compliant
function is_string_max_char_compliant {

	local data="$1"
	local maxChars="$2"

	local ok=0

	if [ "${#data}" -gt "$maxChars" ]; then
		ok=1
	fi

	return $ok
}




######################################################
# Read config file and set variables


if [ ! -f "$config" ]; then
	display_error "Could not read configuration file $config" "$commitMsg"
	exit 1
fi


readonly enabled=$(jq -r '.enabled' $config)
if [ "$enabled" = "null" ]; then
	display_error "Could not find property 'enabled' in configuration file $config" "$commitMsg"
	exit 1
fi

# early exit if script isn't enabled
if [[ "$enabled" = false ]]; then
	display_warning_proceed "commit-msg script disabled."
	exit 0
fi

readonly titleLineLengthMin=$(jq -r '.length.titleLine.min' $config)
if [ "$titleLineLengthMin" = "null" ]; then
	display_error "Could find property 'length.titleLine.min' in configuration file $config" "$commitMsg"
	exit 1
fi

readonly titleLineLengthMax=$(jq -r '.length.titleLine.max' $config)
if [ "$titleLineLengthMax" = "null" ]; then
	display_error "Could find property 'length.titleLine.max' in configuration file $config" "$commitMsg"
	exit 1
fi

readonly bodyLineLengthMin=$(jq -r '.length.bodyLine.min' $config)
if [ "$bodyLineLengthMin" = "null" ]; then
	display_error "Could find property 'length.bodyLine.min' in configuration file $config" "$commitMsg"
	exit 1
fi

readonly bodyLineLengthMax=$(jq -r '.length.bodyLine.max' $config)
if [ "$bodyLineLengthMax" = "null" ]; then
	display_error "Could find property 'length.bodyLine.max' in configuration file $config" "$commitMsg"
	exit 1
fi

scopesTest=$(jq -r '.scopes' $config)
if [ "$scopesTest" = "null" ]; then
	display_error "Could not find property 'scopes' in configuration file $config" "$commitMsg"
	exit 1
else
	unset scopesTest
	#readonly scopesString=$(jq -r '.scopes[] | .name' $config)
	# convert string to array.  do not use quote marks.
	#readonly scopes=($scopesString)
fi
# the function above is unchanged as experimention is done below
#   - once done, the test for presences of the .scopes in json should be kept,
#   - then the 'scopes' array should be replace with that below


# todo testing
# append: myArray+=( "newElement1" "newElement2" )



# $1 is the scope string extracted from the commit message
# $2 is the config file
# $3 is the commit message
#
# return: a global scopesArray as an array of fully-qualified scopes including the top-level project, replacing aliases with names
function resolve_scope {

	local scopesUser="$1"
	local configFile="$2"
	local commitMsg="$3"

	if [[ -z "$1" ]]; then
		display_error "The 'scope' cannot be empty" "$commitMsg"
		exit 1
	fi

	# valid characters for scope
	local regexp_scope="^[a-zA-Z0-9._-]+$"

	if [[ ! $1 =~ $regexp_scope ]]; then
		display_error "Invalid characters in 'scope'" "$commitMsg"
		exit 1
	fi

	local -a scopesUserArray
	IFS='.' read -r -a scopesUserArray <<< "$scopesUser"

	#echo ${scopesUserArray[*]}


	# ####################################################
	# setup
	local currentScopeString=""
	local -a currentScopesArray
	local currentAliasString
	local reg


	# ####################################################
	# first level:
	#     - could have explicit name or alias of top-level project, or could be  implicit such that using the name/alias of a sub-project

	currentScopesString=$(jq -r '.scopes[] | .name' $config)
	if [ "$currentScopesString" = "null" ]; then
		display_error "Could not find 'name' property for top-level 'scopes' in configuration file $configFile" "$commitMsg"
		exit 1
	else
		# convert string to array.  do not use quote marks.
		currentScopesArray=($currentScopesString)
	fi


	echo "Finding by name for ${scopesUserArray[0]}"


	reg="^${scopesUserArray[0]}$"

	# check if name used
	if [[ ${currentScopesArray[@]} =~ $reg ]]; then
		echo "Found by name"
		# name found
		scopesArray+=( "${currentScopesArray[0]}" )
	else
		echo "Not found by name"
		echo "Finding by alias"

		# name not found; check if alias used

		currentAliasString=$(jq -r '.scopes[] | .alias' $config)
		if [ ! "$currentAliasString" = "null" ]; then

			if [[ $currentAliasString =~ $reg ]]; then
				# alias found
				echo "Found by alias"
				scopesArray+=( "${currentScopesArray[0]}" )
			else
				echo "Not found by alias"
			fi

		else
			echo "Not found by alias, no alias set"

		fi

	fi



	# set start index in the scopesUserArray is 1, assuming the first element was found as the top-level project
	local startIndex=1


	if [[ ${#scopesArray[@]} -eq 0 ]]; then

		echo "Didn't find scope, adding name"
		scopesArray+=( "${currentScopesArray[0]}" )

		# first element was not top-level project, so set index to 0
		startIndex=0
	fi


	# ####################################################
	# second level and after:
	#     - either the first scopesUserArray element was:
	#        - a top-level project was specified by name/alias, then: scopesArray has one element and continue at scopesUserArray index = 1
	#        - a sub-project, so not found, then: scopesArray is empty and continue at scopesUserArray index = 0 


	# get length of an array
	local length=${#scopesUserArray[@]}



   currentScopesString=$(jq -r --arg scope "$scope" '.scopes[] | select(.name==$scope) | .scopes[] | .name' $config)

	echo "***************************"
	echo "startIndex: $startIndex"

	echo "scopesArray: ${scopesArray[*]}"
	echo "***************************"
	echo " "


	 
	# use C style for loop syntax to read all values and indexes
	for (( j="$startIndex"; j<length; j++ ));
	do
		echo "---------------------------"
		printf "Current index %d with value %s\n" $j "${scopesUserArray[$j]}"
		echo "---------------------------"
	done


	echo " "
	echo "***************************"






	#scopesTest=$(jq -r '.scopes' $1)
	#if [ "$scopesTest" = "null" ]; then
	#	display_error "Could not find top-level property 'scopes' in configuration file $configFile" "$commitMsg"
	#	exit 1
	#else
	#	unset scopesTest
		# retrieve top-level scopes, which should only be 1 e.g. 'project', 'proj', etc.
	#	readonly scopesAllString=$(jq -r '.scopes[] | .name' $1)
		# convert string to array.  do not use quote marks.
	#	readonly scopesAll=($scopesString)
	#fi


	# display error message and exit if more than top-level scope defined
	#if [ "${#scopesAll[@]}" -ne 1 ]; then
	#	display_error "Configuration file $configFile has more than one top-level scope defined" "$commitMsg"
	#	exit 1
	#fi

	# scopesAll
	# currentScopes ... done with it
	#currentPath=${scopesAll[0]}

}


testScope="proj.client"

declare -a scopesArray

resolve_scope "$testScope"

echo "testScope= $testScope"
echo "global scopesArray= ${scopesArray[*]}"



#unset currentScopes
#unset currentPath


#echo $scopesAll

#echo "next"
#echo $(jq -r '.scopes[] | .scopes[] | .name' $config)
#echo "end"


# input: 'scope' string from regex
#
#   proj
#   p
#
#   client
#   c
#   proj.client
#
#   client.blah
#   proj.client.blah


# convert aliases to names
#
# produce global 'scopeFullyQualified' string:
#    proj
#    proj.client
#    proj.client.blah
#    proj.client.yada
#    proj.server
#    proj.ex-cfg
#    proj.readme


echo "***********************"
echo "Testing exit"
exit 1

######################################################
# Re-format commit message


# delete all lines that contain a comment
sed -i '/#/d' "$1"

# replace a line with 1 or more spaces and newline with a newline only (removing spaces)
sed -i 's/^[ ]*$/\n/' "$1"

# replace two or more consecutive newlines with a single newline
sed -i '/^$/N;/^\n$/D' "$1"

# remove one or more newlines to EOF
sed -i -e :a -e '/^\n*$/{$d;N;ba' -e '}' "$1"

# In the title line (first line):

	# remove extra spaces at the start of the line 
	sed -i '1 s/^[ ]*//' "$1"

	# remove extra spaces before the opening parenthesis
	sed -i '1 s/[ ]*(/(/' "$1"

	# remove extra spaces after the opening parenthesis
	sed -i '1 s/([ ]*/(/' "$1"

	# remove extra spaces before the closing parenthesis
	sed -i '1 s/[ ]*)/)/' "$1"

	# remove extra spaces after the closing parenthesis
	sed -i '1 s/)[ ]*/)/' "$1"

	# remove extra spaces before the exclamation mark
	sed -i '1 s/[ ]*!/!/' "$1"

	# remove extra spaces before the colon
	sed -i '1 s/[ ]*:/:/' "$1"

	# replace extra spaces after the colon with a single space
	sed -i '1 s/:[ ]*/: /' "$1"

# In the body:

	# converts to 'BREAKING CHANGE: '
		# 'BREAKING CHANGE', regardless of case
		# 'BREAKING' if mis-spelled 'BRAKING' or 'BRAEKING'
		# 'BREAKING' and 'CHANGE' if separated by 0 or more spaces, a dash, or underscore
		# multiple spaces before or after the colon
   sed -i 's/BRE\?AKING[ -_]*CHANGE[ ]*:[ ]*/BREAKING CHANGE: /i' "$1"
   sed -i 's/BRAEKING[ -_]*CHANGE[ ]*:[ ]*/BREAKING CHANGE: /i' "$1"


######################################################
# Validate commit message

# Check if the file is empty; a file containing newlines and/or white space only is considered empty
if [ -z "$(cat "${1}")" ]; then
	display_error "Commit message cannot be empty." "$1"
	exit 1
fi

# fail if tab characters are used
	# used literal tab character here in regex by using ctrl-v then tab
	# do after all comments removed, since those are being removed because not sent anyway
		# note that commit comments automatically added by commit contain tabs
lineNum=$(sed -n '/	/=' "$1")
if [ -n "$lineNum" ]; then
	display_error "Commit message must not contain tabs, but tab found on line # $lineNum." "$1" "$lineNum"
	exit 1
fi


# eval title line (first line)
while IFS= read -r line
do

	# Check that the title line is non-empty.  This is in compliance with the format, and will be prevent script errors if the git message is aborted.
	if [[ -z "$line" ]]; then
		display_error 'Title line (first line) cannot be empty'
		exit 1
	fi

	# check that the title line has at least min chars
	if is_string_min_char_compliant "$line" "$titleLineLengthMin"; then

		# check that the title line doesn't exceed max chars
		if is_string_max_char_compliant "$line" "$titleLineLengthMax"; then

			# make a copy to use later (if needed), because regex clobbers it
			line2=$line

			# regex for:  type (required), scope (required), and exclamation mark (optional).  1 or more characters necessary for type and scope, but otherwise doesn't check number of characters
			regexp="^([a-zA-Z]+)(\(([a-zA-Z0-9]+)\))?([\!])?: [a-z]"

			if [[ $line =~ $regexp ]]; then
				theType=${BASH_REMATCH[1]}
				scope=${BASH_REMATCH[3]}
			else
				theType=''
				scope=''
			fi
			# if needed later, the exclamation mark can be captured with ${BASH_REMATCH[4]}



			# scope must be found from regex
			if [ -z "$scope" ]; then

				errMsg=''

				# test if title line of the first letter of the subject is uppercase, for some feedback
				regexp2="^([a-zA-Z]+)(\(([a-zA-Z0-9]+)\))?([\!])?: [A-Z]"

				if [[ $line2 =~ $regexp2 ]]; then
					scope=${BASH_REMATCH[3]}
				else
					scope=''
				fi

				if [ ! -z "$scope" ]; then
					errMsg="The first letter of the subject shouldn't be capitalized.  "
				fi

				errMsg="$errMsg""Bad form of title line.  Could not determine 'scope'."

				display_error "$errMsg" "$1" 1

				exit 1
			fi

			# check if scope defined in the config file
			scopeFound='no'
			for value in "${scopes[@]}"
			do
				if [[ "$scope" = "$value" ]]; then
					scopeFound='yes'
					break
				fi
			done

			# error if scope wasn't defined in config file
			if [[ ! "$scopeFound" = "yes" ]]; then
				display_error "Scope '$scope' is not a valid scope per configuration file '$config'." "$1" 1
				exit 1
			fi


			# type must be found from regex
			if [ -z "$theType" ]; then
				display_error "Bad form of title line.  Could not determine 'type'." "$1" 1
				exit 1
			fi

			# retrieve the types from the defined scope
			readonly typesString=$(jq -r --arg scope "$scope" '.scopes[] | select(.name==$scope) | .types[]' $config)
			# convert string to array.  do not use quote marks.
			readonly types=($typesString)

			# check if type defined in config file
			typeFound='no'
			for value in "${types[@]}"
			do
				if [[ "$theType" = "$value" ]]; then
					typeFound='yes'
					break
				fi
			done

			# error if type wasn't defined in config file
			if [[ ! "$typeFound" = "yes" ]]; then
				display_error "Type '$theType' is not a valid type for the scope '$scope' per configuration file '$config'." "$1" 1
				exit 1
			fi

		else
			display_error "Title line (first line) must not contain more than $titleLineLengthMax characters as defined in the configuration file '$config'." "$1" "$count"
			exit 1
		fi

	else
		display_error "Title line (first line) must contain at least $titleLineLengthMin characters as defined in the configuration file '$config'." "$1" "$count"
		exit 1
	fi

done < <(head -1 "$1")


# eval lines 2 and after

mode='title'
count=2
countBreakingChange=0

while IFS= read -r line
do

	if [[ "$mode" = "title" ]]; then

		if [ -z "$line" ]; then
			# 2nd line is a newline
			mode='body'
		else
			# 2nd line is present, and isn't a newline (e.g. empty line)
			display_error "Second line, if present, must be empty." "$1" "$count"
			exit 1
		fi

	elif [[ "$mode" = "body" ]]; then

		# remain in this mode until EOF

		if [ -n "$line" ]; then
			#line isn't empty

			# check that the line has at least min chars
			if is_string_min_char_compliant "$line" "$bodyLineLengthMin"; then

				# check that the tline doesn't exceed max chars
				if is_string_max_char_compliant "$line" "$bodyLineLengthMax"; then

					# the reformatting ensures this form, if present
					regexp="BREAKING CHANGE: ([a-zA-Z])"

					if [[ $line =~ $regexp ]]; then
						(( "countBreakingChange++" ))
					fi

				else
					display_error "Body line must not contain more than $bodyLineLengthMax characters as defined in the configuration file '$config'." "$1" "$count"
					exit 1
				fi
			else
				display_error "Body line must contain at least $bodyLineLengthMin characters as defined in the configuration file '$config'." "$1" "$count"
				exit 1
			fi
		fi
	fi


	(( "count++" ))

done < <(tail -n +2 "$1")


if [ "$countBreakingChange" -gt 1 ]; then
	display_error "Only one 'BREAKING CHANGE' statement allowed." "$1"
	exit 1
fi


# note that not checking tokens in footer, and specifically that they contain a '-'
