#!/bin/env bash
# (c) Copyright 2023 KineticFire. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


# KineticFire Labs
#	  Project site:  https://github.com/kineticfire-labs/git-conventional-commits-hooks


##########################################################################
##########################################################################
##########################################################################
# Setup & Usage
# 
# Setup
#    - Add this script to <git repository>/.git/hooks/commit-msg'
#	  - Make this script executable with 'chmod +x <path to script>' 
#    - Set the default editor for git ('vim' in the example below)
#         - git config --global core.editor vim
#
# Usage
#    - This script will be invoked by git during commits.  Run the command 'git commit'.
#
# Limitations
#    - This is a client-side script, which is enforcing the conventions at the client only and not the server.



##########################################################################
##########################################################################
##########################################################################
# Detailed Description
#
# If '.enabled' in the config file is 'false', then this script will exit and return 0 (allowing the commit) without reformatting or validation described below.
#
# This script will exit and return 1 (rejecting the commit) if one of the following are true, else this script will return 0 (accepting the commit):
#  - the configuration file cannot be read
#  - a property of the configuration file cannot be found
#  - the validation of the commit message fails
#
# The commit message reformatting and validation follows the Conventional Commits specification (https://www.conventionalcommits.org/en/v1.0.0/).  A commit message consists of at least one line.  If additional lines are given, then the body is separated from the subject line by exactly one newline. So a commit message may take the following two general forms.  This script requires a 'type' and 'scope'; the '!' is optional.  See the Conventional Commits specification for more detail, and consult your project's specific configuration for valid git commit messages.
#
# (1)
#   --- start ---
#   <type>(<scope>)!: <subject>
#   ---- end ----
#
# (2)
#   --- start ---
#   <type>(<scope>)!: <subject>
#
#   <body>
#   ---- end ----
#
# The commit message is re-formatted prior to validation as follows:
#  - Remove all lines with comments
#  - Replace a line containing only spaces (e.g. 1 or more spaces and newline) with a newline only
#  - Replace two or more empty lines (e.g. newlines that may contain 0 or more spaces) with a single empty line
#  - Remove trailing newlines
#  - For the title line (e.g. the first line):
#    - Remove extra spaces before and after the 'type'
#    - Remove extra spaces before and after the opening and closing parenthesis for the 'scope'
#    - Remove extra spaces before and after the optional exclamation mark following the 'type' and 'scope' and prior to the colon
#    - Remove extra spaces before and after the colon
#  - For the body:
#    - converts the following to 'BREAKING CHANGE: '
#      - 'BREAKING CHANGE', regardless of case
#      - 'BREAKING' if mis-spelled 'BRAKING' or 'BRAEKING'
#      - 'BREAKING' and 'CHANGE' if separated by 0 or more spaces, a dash, or underscore
#      - multiple spaces before or after the colon
#
# The commit message is valid if, after reformatting, the following are all true:
#  - Title line must be a valid subject
#    - At least length.titleLine.min characters (from config file) in length
#    - No more than length.titleLine.max characters (from config file) in length
#    - '<type>(<scope>)!: <subject>' where 'type' and 'scope' are defined in the config file, type and scope are required , and '!' optionally indicates a breaking change.  The subject must begin with a lowercase letter.
#    - Examples with type of 'feat' and scope of 'app': 
#      - Non-breaking change:
#        - feat(app): add this feature
#      - Breaking change:
#        - feat(app)!: add this feature
#  - After the title line:
#    - Option 1: title line only, no body
#      - end of file
#    - Option 2: with body
#      - one newline
#      - body, which can contain text and newlines
#      - optional single 'BREAKING CHANGE: <description>'
#      - end of file
#
# Requirements:
#  - bash
#  - sed
#  - jq
#  - cat
#  - tail
#  - head

######################################################
# Define settings

version=1.0.0

# set configuration file
config=commit-msg.cfg.json


######################################################
# Define functions


# $1 is String error message
function display_error_message {
	echo -e "\e[1m\e[31m[COMMIT REJECTED (local)]"
	echo -e "\e[0m\e[1mCommit failed: $1"
}


# $1 is String warning message
function display_warning_proceed {
	echo -e "\e[34mWARNING (local): $1  Commit proceeding.\033[0m\e[0m"
}


# $1 is String warning message
# $2 is optional integer line number to highlight in red
function display_commit_message {
	echo -e "\e[34m**********************************************"
	echo 'BEGIN - COMMIT MESSAGE ***********************'
	if [[ -n "$2" ]]; then
		echo "   (offending line # $2 in red) **************"
	fi
	echo -e "**********************************************\033[0m\e[0m"

	count=0

	while IFS= read -r line
	do
		(( "count++" ))
		if [[ -n "$2" ]] && [ "$count" -eq "$2" ]; then
			echo -e "\e[1m\e[31m$line\033[0m\e[0m"
		else
			echo "$line"
		fi
	done < "$1"

   echo -e "\e[34m**********************************************"
	echo 'END - COMMIT MESSAGE *************************'
   echo -e "**********************************************\033[0m\e[0m"
}


# $1 is String warning message
# $2 is the commit message file
# $3 is optional integer line number to highlight in red
function display_error {
	echo -e "\n"
	display_error_message "$1"
	echo -e "\n"
	display_commit_message "$2" "$3"
	echo -e "\n"
}


function display_info {
	echo "Version $version"
}


# $1 is the String to evaluate
# $2 is the int min number of chars
# return: 0 is compliant, 1 is not compliant
function is_string_min_char_compliant {

	ok=0

	if [ "${#1}" -lt "$2" ]; then
		ok=1
	fi

	return $ok
}


# $1 is the String to evaluate
# $2 is the int max number of chars
# return: 0 is compliant, 1 is not compliant
function is_string_max_char_compliant {

	ok=0

	if [ "${#1}" -gt "$2" ]; then
		ok=1
	fi

	return $ok
}




######################################################
# Read config file and set variables


if [ ! -f "$config" ]; then
	display_error "Could not read configuration file $config" "$1"
	exit 1
fi


readonly enabled=$(jq -r '.enabled' $config)
if [ "$enabled" = "null" ]; then
	display_error "Could not find property 'enabled' in configuration file $config" "$1"
	exit 1
fi

# early exit if script isn't enabled
if [[ "$enabled" = false ]]; then
	display_warning_proceed "commit-msg script disabled."
	exit 0
fi

readonly titleLineLengthMin=$(jq -r '.length.titleLine.min' $config)
if [ "$titleLineLengthMin" = "null" ]; then
	display_error "Could find property 'length.titleLine.min' in configuration file $config" "$1"
	exit 1
fi

readonly titleLineLengthMax=$(jq -r '.length.titleLine.max' $config)
if [ "$titleLineLengthMax" = "null" ]; then
	display_error "Could find property 'length.titleLine.max' in configuration file $config" "$1"
	exit 1
fi

readonly bodyLineLengthMin=$(jq -r '.length.bodyLine.min' $config)
if [ "$bodyLineLengthMin" = "null" ]; then
	display_error "Could find property 'length.bodyLine.min' in configuration file $config" "$1"
	exit 1
fi

readonly bodyLineLengthMax=$(jq -r '.length.bodyLine.max' $config)
if [ "$bodyLineLengthMax" = "null" ]; then
	display_error "Could find property 'length.bodyLine.max' in configuration file $config" "$1"
	exit 1
fi

scopesTest=$(jq -r '.scopes' $config)
if [ "$scopesTest" = "null" ]; then
	display_error "Could not find property 'scopes' in configuration file $config" "$1"
	exit 1
else
	unset scopesTest
	readonly scopesString=$(jq -r '.scopes[] | .name' $config)
	# convert string to array.  do not use quote marks.
	readonly scopes=($scopesString)
fi


######################################################
# Re-format commit message


# delete all lines that contain a comment
sed -i '/#/d' "$1"

# replace a line with 1 or more spaces and newline with a newline only (removing spaces)
sed -i 's/^[ ]*$/\n/' "$1"

# replace two or more consecutive newlines with a single newline
sed -i '/^$/N;/^\n$/D' "$1"

# remove one or more newlines to EOF
sed -i -e :a -e '/^\n*$/{$d;N;ba' -e '}' "$1"

# In the title line (first line):

	# remove extra spaces at the start of the line 
	sed -i '1 s/^[ ]*//' "$1"

	# remove extra spaces before the opening parenthesis
	sed -i '1 s/[ ]*(/(/' "$1"

	# remove extra spaces after the opening parenthesis
	sed -i '1 s/([ ]*/(/' "$1"

	# remove extra spaces before the closing parenthesis
	sed -i '1 s/[ ]*)/)/' "$1"

	# remove extra spaces after the closing parenthesis
	sed -i '1 s/)[ ]*/)/' "$1"

	# remove extra spaces before the exclamation mark
	sed -i '1 s/[ ]*!/!/' "$1"

	# remove extra spaces before the colon
	sed -i '1 s/[ ]*:/:/' "$1"

	# replace extra spaces after the colon with a single space
	sed -i '1 s/:[ ]*/: /' "$1"

# In the body:

	# converts to 'BREAKING CHANGE: '
		# 'BREAKING CHANGE', regardless of case
		# 'BREAKING' if mis-spelled 'BRAKING' or 'BRAEKING'
		# 'BREAKING' and 'CHANGE' if separated by 0 or more spaces, a dash, or underscore
		# multiple spaces before or after the colon
   sed -i 's/BRE\?AKING[ -_]*CHANGE[ ]*:[ ]*/BREAKING CHANGE: /i' "$1"
   sed -i 's/BRAEKING[ -_]*CHANGE[ ]*:[ ]*/BREAKING CHANGE: /i' "$1"


######################################################
# Validate commit message

# Check if the file is empty; a file containing newlines and/or white space only is considered empty
if [ -z "$(cat "${1}")" ]; then
	display_error "Commit message cannot be empty." "$1"
	exit 1
fi

# fail if tab characters are used
	# used literal tab character here in regex by using ctrl-v then tab
	# do after all comments removed, since those are being removed because not sent anyway
		# note that commit comments automatically added by commit contain tabs
lineNum=$(sed -n '/	/=' "$1")
if [ -n "$lineNum" ]; then
	display_error "Commit message must not contain tabs, but tab found on line # $lineNum." "$1" "$lineNum"
	exit 1
fi


# eval title line (first line)
while IFS= read -r line
do

	# Check that the title line is non-empty.  This is in compliance with the format, and will be prevent script errors if the git message is aborted.
	if [[ -z "$line" ]]; then
		display_error 'Title line (first line) cannot be empty'
		exit 1
	fi

	# check that the title line has at least min chars
	if is_string_min_char_compliant "$line" "$titleLineLengthMin"; then

		# check that the title line doesn't exceed max chars
		if is_string_max_char_compliant "$line" "$titleLineLengthMax"; then

			# make a copy to use later (if needed), because regex clobbers it
			line2=$line

			# regex for:  type (required), scope (required), and exclamation mark (optional).  1 or more characters necessary for type and scope, but otherwise doesn't check number of characters
			regexp="^([a-zA-Z]+)(\(([a-zA-Z0-9]+)\))?([\!])?: [a-z]"

			if [[ $line =~ $regexp ]]; then
				theType=${BASH_REMATCH[1]}
				scope=${BASH_REMATCH[3]}
			else
				theType=''
				scope=''
			fi
			# if needed later, the exclamation mark can be captured with ${BASH_REMATCH[4]}



			# scope must be found from regex
			if [ -z "$scope" ]; then

				errMsg=''

				# test if title line of the first letter of the subject is uppercase, for some feedback
				regexp2="^([a-zA-Z]+)(\(([a-zA-Z0-9]+)\))?([\!])?: [A-Z]"

				if [[ $line2 =~ $regexp2 ]]; then
					scope=${BASH_REMATCH[3]}
				else
					scope=''
				fi

				if [ ! -z "$scope" ]; then
					errMsg="The first letter of the subject shouldn't be capitalized.  "
				fi

				errMsg="$errMsg""Bad form of title line.  Could not determine 'scope'."

				display_error "$errMsg" "$1" 1

				exit 1
			fi

			# check if scope defined in the config file
			scopeFound='no'
			for value in "${scopes[@]}"
			do
				if [[ "$scope" = "$value" ]]; then
					scopeFound='yes'
					break
				fi
			done

			# error ir scope wasn't defined in config file
			if [[ ! "$scopeFound" = "yes" ]]; then
				display_error "Scope '$scope' is not a valid scope per configuration file '$config'." "$1" 1
				exit 1
			fi


			# type must be found from regex
			if [ -z "$theType" ]; then
				display_error "Bad form of title line.  Could not determine 'type'." "$1" 1
				exit 1
			fi

			# retrieve the types from the defined scope
			readonly typesString=$(jq -r --arg scope "$scope" '.scopes[] | select(.name==$scope) | .types[]' $config)
			# convert string to array.  do not use quote marks.
			readonly types=($typesString)

			# check if type defined in config file
			typeFound='no'
			for value in "${types[@]}"
			do
				if [[ "$theType" = "$value" ]]; then
					typeFound='yes'
					break
				fi
			done

			# error if type wasn't defined in config file
			if [[ ! "$typeFound" = "yes" ]]; then
				display_error "Type '$theType' is not a valid type for the scope '$scope' per configuration file '$config'." "$1" 1
				exit 1
			fi

		else
			display_error "Title line (first line) must not contain more than $titleLineLengthMax characters as defined in the configuration file '$config'." "$1" "$count"
			exit 1
		fi

	else
		display_error "Title line (first line) must contain at least $titleLineLengthMin characters as defined in the configuration file '$config'." "$1" "$count"
		exit 1
	fi

done < <(head -1 "$1")


# eval lines 2 and after

mode='title'
count=2
countBreakingChange=0

while IFS= read -r line
do

	if [[ "$mode" = "title" ]]; then

		if [ -z "$line" ]; then
			# 2nd line is a newline
			mode='body'
		else
			# 2nd line is present, and isn't a newline (e.g. empty line)
			display_error "Second line, if present, must be empty." "$1" "$count"
			exit 1
		fi

	elif [[ "$mode" = "body" ]]; then

		# remain in this mode until EOF

		if [ -n "$line" ]; then
			#line isn't empty

			# check that the line has at least min chars
			if is_string_min_char_compliant "$line" "$bodyLineLengthMin"; then

				# check that the tline doesn't exceed max chars
				if is_string_max_char_compliant "$line" "$bodyLineLengthMax"; then

					# the reformatting ensures this form, if present
					regexp="BREAKING CHANGE: ([a-zA-Z])"

					if [[ $line =~ $regexp ]]; then
						(( "countBreakingChange++" ))
					fi

				else
					display_error "Body line must not contain more than $bodyLineLengthMax characters as defined in the configuration file '$config'." "$1" "$count"
					exit 1
				fi
			else
				display_error "Body line must contain at least $bodyLineLengthMin characters as defined in the configuration file '$config'." "$1" "$count"
				exit 1
			fi
		fi
	fi


	(( "count++" ))

done < <(tail -n +2 "$1")


if [ "$countBreakingChange" -gt 1 ]; then
	display_error "Only one 'BREAKING CHANGE' statement allowed." "$1"
	exit 1
fi


# note that not checking tokens in footer, and specifically that they contain a '-'
