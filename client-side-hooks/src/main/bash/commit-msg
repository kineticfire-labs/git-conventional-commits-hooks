#!/bin/bash
# (c) Copyright 2023 KineticFire. All rights reserved.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


# If '.enabled' in the config file is 'false', then this script will exit and return 0 (allowing the commit) without reformatting or validation described below.
#
# This script will exit and return 1 (rejecting the commit) if one of the following are true, else this script will return 0 (accepting the commit):
#  - the configuration file cannot be read
#  - a property of the configuration file cannot be found
#  - the validation of the commit message fails
#
# The commit message reformatting and validation follows the Conventional Commits specification (https://www.conventionalcommits.org/en/v1.0.0/).  A commit message consists of at least one line.  If additional lines are given, then the body is separated from the subject line by exactly one newline. So a commit message may take the following two general forms.  In both cases:  the 'scope' and '!' are optional.  See the Conentional Commits specification for more detail, and consult your project's specific configuration for valid git commit messages.
#
# (1)
#   <type>(<scope>)!: <subject>
#
# (2)
#   <type>(<scope>)!: <subject>
#
#   <body>
#
# The commit message is re-formatted prior to validation as follows:
#  - Remove all lines with comments
#  - Replace a line containing only spaces (e.g. 1 or more spaces and newline) with a newline only
#  - Replace two or more empty lines (e.g. newlines that may contain 0 or more spaces) with a single empty line
#  - Remove trailing newlines
#  - For the subject line (e.g. the first line):
#    - Remove extra spaces before and after the 'type'
#    - Remove extra spaces before and after the opening and closing parenthesis for the optional 'scope'
#    - Remove extra spaces before and after the optional exclamation mark following the 'type' and optional 'scope' and prior to the colon
#    - Remove extra spaces before and after the colon
#  - For the body:
#    - converts the following to 'BREAKING CHANGE: '
#      - 'BREAKING CHANGE', regardless of case
#      - 'BREAKING' if mis-spelled 'BRAKING' or 'BRAEKING'
#      - 'BREAKING' and 'CHANGE' if separated by 0 or more spaces, a dash, or underscore
#      - multiple spaces before or after the colon
#
# The commit message is valid if, after reformatting, the following are all true:
#  - First line must be a valid subject
#    - At least length.firstLine.min characters (from config file) in length
#    - No more than length.firstLine.max characters (from config file) in length
#    - '<type>(<scope>)!: <subject>' where 'type' and 'scope' are defined in the config file, scope is optional based on 'scopeEnabled' (from config file), and '!' optionally indicates a breaking change.  The subject must begin with a lowercase letter.
#    - Examples with type of 'feat' and scope of 'app': 
#      - No scope and no breaking change
#        - feat: add this feature
#      - No scope and with a breaking change:
#        - feat!: add this feature
#      - Scope and breaking change:
#        - feat(app)!: add this feature
#  - After the first line:
#    - Option 1: subject line only, no body
#      - end of file
#    - Option 2: with body
#      - one newline
#      - body, which can contain text and newlines
#      - optional single 'BREAKING CHANGE: <description>'
#      - end of file
#
# Requirements:
#  - bash
#  - sed
#  - jq
#  - cat
#  - tail
#  - head


######################################################
# Define settings

version=1

# set configuration file
config=commit-msg.cfg.json


######################################################
# Define functions


# $1 is String error message
function display_error_message {
	echo -e "\e[1m\e[31m[COMMIT REJECTED (local)]"
	echo -e "\e[0m\e[1mCommit failed: $1"
}


# $1 is String warning message
function display_warning_proceed {
	echo -e "\e[34mWARNING (local): $1  Commit proceeding.\033[0m\e[0m"
}


# $1 is String warning message
# $2 is optional integer line number to highlight in red
function display_commit_message {
	echo -e "\e[34m**********************************************"
	echo 'BEGIN - COMMIT MESSAGE ***********************'
	if [[ -n "$2" ]]; then
		echo "   (offending line # $2 in red) **************"
	fi
	echo -e "**********************************************\033[0m\e[0m"

	count=0

	while IFS= read -r line
	do
		(( "count++" ))
		if [[ -n "$2" ]] && [ "$count" -eq "$2" ]; then
			echo -e "\e[1m\e[31m$line\033[0m\e[0m"
		else
			echo "$line"
		fi
	done < "$1"

   echo -e "\e[34m**********************************************"
	echo 'END - COMMIT MESSAGE *************************'
   echo -e "**********************************************\033[0m\e[0m"
}


# $1 is String warning message
# $2 is the commit message file
# $3 is optional integer line number to highlight in red
function display_error {
	echo -e "\n"
	display_error_message "$1"
	echo -e "\n"
	display_commit_message "$2" "$3"
	echo -e "\n"
}


function display_info {
	echo "Version $version"
}


# $1 is the String to evaluate
# $2 is the int min number of chars
# return: 0 is compliant, 1 is not compliant
function is_string_min_char_compliant {

	ok=0

	if [ "${#1}" -lt "$2" ]; then
		ok=1
	fi

	return $ok
}


# $1 is the String to evaluate
# $2 is the int max number of chars
# return: 0 is compliant, 1 is not compliant
function is_string_max_char_compliant {

	ok=0

	if [ "${#1}" -gt "$2" ]; then
		ok=1
	fi

	return $ok
}




######################################################
# Read config file and set variables


if [ ! -f "$config" ]; then
	display_error "Could not read configuration file $config" "$1"
	exit 1
fi


readonly enabled=$(jq -r '.enabled' $config)
if [ "$enabled" = "null" ]; then
	display_error "Could not find property 'enabled' in configuration file $config" "$1"
	exit 1
fi

# early exit if script isn't enabled
if [[ "$enabled" = false ]]; then
	display_warning_proceed "commit-msg script disabled."
	# todo
	echo "todo for testing, exiting"
	exit 1
	exit 0
fi

readonly scopesEnabled=$(jq -r '.scopesEnabled' $config)
if [ "$scopesEnabled" = "null" ]; then
	display_error "Could not find property 'scopesEnabled' in configuration file $config" "$1"
	exit 1
fi

readonly firstLineLengthMin=$(jq -r '.length.firstLine.min' $config)
if [ "$firstLineLengthMin" = "null" ]; then
	display_error "Could find property 'length.firstLine.min' in configuration file $config" "$1"
	exit 1
fi

readonly firstLineLengthMax=$(jq -r '.length.firstLine.max' $config)
if [ "$firstLineLengthMax" = "null" ]; then
	display_error "Could find property 'length.firstLine.max' in configuration file $config" "$1"
	exit 1
fi

readonly bodyLineLengthMin=$(jq -r '.length.bodyLine.min' $config)
if [ "$bodyLineLengthMin" = "null" ]; then
	display_error "Could find property 'length.bodyLine.min' in configuration file $config" "$1"
	exit 1
fi

readonly bodyLineLengthMax=$(jq -r '.length.bodyLine.max' $config)
if [ "$bodyLineLengthMax" = "null" ]; then
	display_error "Could find property 'length.bodyLine.max' in configuration file $config" "$1"
	exit 1
fi

typesTest=$(jq -r '.types' $config)
if [ "$typesTest" = "null" ]; then
	display_error "Could not find property 'types' in configuration file $config" "$1"
	exit 1
else
	unset typesTest
	mapfile -t types < <(jq -r '.types[]' $config)
fi

scopesTest=$(jq -r '.scopes' $config)
if [ "$scopesTest" = "null" ]; then
	display_error "Could not find property 'scopes' in configuration file $config" "$1"
	exit 1
else
	unset scopesTest
	mapfile -t scopes < <(jq -r '.scopes[]' $config)
fi


######################################################
# Re-format commit message


# delete all lines that contain a comment
sed -i '/#/d' "$1"

# replace a line with 1 or more spaces and newline with a newline only (removing spaces)
sed -i 's/^[ ]*$/\n/' "$1"

# replace two or more consecutive newlines with a single newline
sed -i '/^$/N;/^\n$/D' "$1"

# remove one or more newlines to EOF
sed -i -e :a -e '/^\n*$/{$d;N;ba' -e '}' "$1"

# In the first line:

	# remove extra spaces at the start of the line 
	sed -i '1 s/^[ ]*//' "$1"

	# remove extra spaces before the opening parenthesis
	sed -i '1 s/[ ]*(/(/' "$1"

	# remove extra spaces after the opening parenthesis
	sed -i '1 s/([ ]*/(/' "$1"

	# remove extra spaces before the closing parenthesis
	sed -i '1 s/[ ]*)/)/' "$1"

	# remove extra spaces after the closing parenthesis
	sed -i '1 s/)[ ]*/)/' "$1"

	# remove extra spaces before the exclamation mark
	sed -i '1 s/[ ]*!/!/' "$1"

	# remove extra spaces before the colon
	sed -i '1 s/[ ]*:/:/' "$1"

	# replace extra spaces after the colon with a single space
	sed -i '1 s/:[ ]*/: /' "$1"

# In the body:

	# converts to 'BREAKING CHANGE: '
		# 'BREAKING CHANGE', regardless of case
		# 'BREAKING' if mis-spelled 'BRAKING' or 'BRAEKING'
		# 'BREAKING' and 'CHANGE' if separated by 0 or more spaces, a dash, or underscore
		# multiple spaces before or after the colon
   sed -i 's/BRE\?AKING[ -_]*CHANGE[ ]*:[ ]*/BREAKING CHANGE: /i' "$1"
   sed -i 's/BRAEKING[ -_]*CHANGE[ ]*:[ ]*/BREAKING CHANGE: /i' "$1"


######################################################
# Validate commit message

# Check if the file is empty; a file containing newlines and/or white space only is considered empty
if [ -z "$(cat "${1}")" ]; then
	display_error "Commit message cannot be empty." "$1"
	exit 1
fi

# fail if tab characters are used
	# used literal tab character here in regex by using ctrl-v then tab
	# do after all comments removed, since those are being removed because not sent anyway
		# note that commit comments automatically added by commit contain tabs
lineNum=$(sed -n '/	/=' "$1")
if [ -n "$lineNum" ]; then
	display_error "Commit message must not contain tabs, but tab found on line # $lineNum." "$1" "$lineNum"
	exit 1
fi


# eval first line
while IFS= read -r line
do

	# Check that hte first line is non-empty.  This is in compliance with thef ormat, and will be prevent script errors if the git message is aborted.
	if [[ -z "$line" ]]; then
		display_error 'First line cannot be empty'
		exit 1
	fi

	# check that the first line has at least min chars
	if is_string_min_char_compliant "$line" "$firstLineLengthMin"; then

		# check that the first line doesn't exceed max chars
		if is_string_max_char_compliant "$line" "$firstLineLengthMax"; then

			# regex for:  type (required), scope (optional), and exclamation mark (optional).  1 or more characters necessary for type and scope, but otherwise doesn't check number of characters
			regexp="^([a-zA-Z]+)(\(([a-zA-Z0-9]+)\))?([\!])?: [a-z]"

			if [[ $line =~ $regexp ]]; then
				theType=${BASH_REMATCH[1]}
				scope=${BASH_REMATCH[3]}
			else
				theType=''
				scope=''
			fi
			# if needed later, the exclamation mark can be captured with ${BASH_REMATCH[4]}

			# type must be found from regex
			if [ -z "$theType" ]; then
				display_error "Bad forma of title line.  Could not determine 'type'." "$1" 1
				exit 1
			fi

			# type must be a type defined in config file
			typeFound='no'
			for value in "${types[@]}"
			do
				if [[ "$theType" = "$value" ]]; then
					typeFound='yes'
					break
				fi
			done

			# error if type wasn't defined in config file
			if [[ ! "$typeFound" = "yes" ]]; then
				display_error "Type '$theType' is not a valid type per configuration file '$config'." "$1" 1
				exit 1
			fi

			# if the scope is found from the regex
			if [ -n "$scope" ]; then

				# scope must be defined in the config file
				scopeFound='no'
				for value in "${scopes[@]}"
				do
					if [[ "$scope" = "$value" ]]; then
						scopeFound='yes'
						break
					fi
				done

				# error ir scope wasn't defined in config file
				if [[ ! "$scopeFound" = "yes" ]]; then
					display_error "Scope '$scope' is not a valid scope per configuration file '$config'." "$1" 1
					exit 1
				fi
			fi

		else
			display_error "First line must not contain more than $firstLineLengthMax characters as defined in the configuration file '$config'." "$1" "$count"
			exit 1
		fi

	else
			display_error "First line must contain at least $firstLineLengthMin characters as defined in the configuration file '$config'." "$1" "$count"
		exit 1
	fi

done < <(head -1 "$1")


# eval lines 2 and after

mode='title'
count=2
countBreakingChange=0

while IFS= read -r line
do

	if [[ "$mode" = "title" ]]; then

		if [ -z "$line" ]; then
			# 2nd line is a newline
			mode='body'
		else
			# 2nd line is present, and isn't a newline (e.g. empty line)
			display_error "Second line, if present, must be empty." "$1" "$count"
			exit 1
		fi

	elif [[ "$mode" = "body" ]]; then

		# remain in this mode until EOF

		if [ -n "$line" ]; then
			#line isn't empty

			# check that the line has at least min chars
			if is_string_min_char_compliant "$line" "$bodyLineLengthMin"; then

				# check that the tline doesn't exceed max chars
				if is_string_max_char_compliant "$line" "$bodyLineLengthMax"; then

					# the reformatting ensures this form, if present
					regexp="BREAKING CHANGE: ([a-zA-Z])"

					if [[ $line =~ $regexp ]]; then
						(( "countBreakingChange++" ))
					fi

				else
					display_error "Body line must not contain more than $bodyLineLengthMax characters as defined in the configuration file '$config'." "$1" "$count"
					exit 1
				fi
			else
				display_error "Body line must contain at least $bodyLineLengthMin characters as defined in the configuration file '$config'." "$1" "$count"
				exit 1
			fi
		fi
	fi


	(( "count++" ))

done < <(tail -n +2 "$1")


if [ "$countBreakingChange" -gt 1 ]; then
	display_error "Only one 'BREAKING CHANGE' statement allowed." "$1"
	exit 1
fi


# note that not checking tokens in footer, and specifically that they contain a '-'


display_error "Always error out for testing" "$1"
exit 1

